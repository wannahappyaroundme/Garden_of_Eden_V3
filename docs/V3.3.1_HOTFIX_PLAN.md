# v3.3.1 Hotfix Plan - IPC Bridge Implementation

**Date**: 2025-01-18
**Priority**: ðŸ”´ CRITICAL
**Estimated Effort**: 4-6 hours
**Target Release**: Within 1-2 days

---

## Problem Statement

The v3.3.0 release has a critical gap: **fully-implemented backend services** (ToolHistoryService, ToolSettingsService) and **fully-implemented frontend UI components** (ToolHistory, ToolResultCard, etc.) **cannot communicate** because the IPC command handlers are missing.

**User Impact**: Tool History panel and Settings panel are non-functional despite having production-ready code on both ends.

---

## Required Changes

### 1. Create Tool History IPC Commands (2-3 hours)

**File**: `src-tauri/src/commands/tool_history.rs` (NEW)

```rust
use tauri::State;
use crate::services::tool_history::{ToolHistoryService, ToolCallRecord, ToolHistoryFilter, ToolStats};
use crate::AppState;

#[tauri::command]
pub async fn get_tool_history(
    state: State<'_, AppState>,
    filters: Option<ToolHistoryFilter>,
) -> Result<Vec<ToolCallRecord>, String> {
    let service = state.tool_history_service.lock().await;
    service.get_history(filters)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn export_tool_history(
    state: State<'_, AppState>,
    format: String,
    filters: Option<ToolHistoryFilter>,
) -> Result<String, String> {
    let service = state.tool_history_service.lock().await;

    let records = service.get_history(filters)
        .map_err(|e| e.to_string())?;

    match format.as_str() {
        "json" => service.export_to_json(&records)
            .map_err(|e| e.to_string()),
        "csv" => service.export_to_csv(&records)
            .map_err(|e| e.to_string()),
        _ => Err("Unsupported format. Use 'json' or 'csv'".to_string()),
    }
}

#[tauri::command]
pub async fn get_tool_statistics(
    state: State<'_, AppState>,
    conversation_id: Option<i64>,
) -> Result<ToolStats, String> {
    let service = state.tool_history_service.lock().await;
    service.get_tool_statistics(conversation_id)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn clear_tool_history(
    state: State<'_, AppState>,
    conversation_id: Option<i64>,
) -> Result<(), String> {
    let service = state.tool_history_service.lock().await;
    service.delete_history(conversation_id)
        .map_err(|e| e.to_string())
}
```

**Tests**: Add integration tests for each command

---

### 2. Create Tool Settings IPC Commands (1-2 hours)

**File**: `src-tauri/src/commands/tool_settings.rs` (NEW)

```rust
use tauri::State;
use crate::services::tool_settings::{ToolSettingsService, ToolSetting};
use crate::AppState;

#[tauri::command]
pub async fn get_tool_settings(
    state: State<'_, AppState>,
) -> Result<Vec<ToolSetting>, String> {
    let service = state.tool_settings_service.lock().await;
    service.get_all_settings()
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn get_tool_setting(
    state: State<'_, AppState>,
    tool_name: String,
) -> Result<ToolSetting, String> {
    let service = state.tool_settings_service.lock().await;
    service.get_tool_setting(&tool_name)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_tool_setting(
    state: State<'_, AppState>,
    setting: ToolSetting,
) -> Result<(), String> {
    let service = state.tool_settings_service.lock().await;
    service.update_tool_setting(&setting)
        .map_err(|e| e.to_string())
}

#[tauri::command]
pub async fn update_tool_settings(
    state: State<'_, AppState>,
    settings: Vec<ToolSetting>,
) -> Result<(), String> {
    let service = state.tool_settings_service.lock().await;
    service.update_all_settings(&settings)
        .map_err(|e| e.to_string())
}
```

**Tests**: Add integration tests for each command

---

### 3. Register Command Modules (15 minutes)

**File**: `src-tauri/src/commands/mod.rs`

```rust
pub mod ai;
pub mod audio;
pub mod conversation;
pub mod onboarding;
pub mod screen;
pub mod settings;
pub mod system;
pub mod learning;
pub mod webhook;
pub mod calendar;
pub mod file;
pub mod git;
pub mod updater;
pub mod crash_reporter;
pub mod tool_history;      // ADD THIS
pub mod tool_settings;     // ADD THIS
```

**File**: `src-tauri/src/main.rs`

Find the `tauri::Builder::default()` section and add to `.invoke_handler()`:

```rust
.invoke_handler(tauri::generate_handler![
    // ... existing commands ...
    commands::tool_history::get_tool_history,
    commands::tool_history::export_tool_history,
    commands::tool_history::get_tool_statistics,
    commands::tool_history::clear_tool_history,
    commands::tool_settings::get_tool_settings,
    commands::tool_settings::get_tool_setting,
    commands::tool_settings::update_tool_setting,
    commands::tool_settings::update_tool_settings,
])
```

---

### 4. Implement Event Emission (1 hour)

**File**: `src-tauri/src/services/ollama.rs`

**Line 565** (replace TODO comment):
```rust
// Emit tool execution start event
if let Some(window) = &self.window {
    let _ = window.emit("tool-execution-start", serde_json::json!({
        "tool_name": tool_name,
        "input": input_params,
        "timestamp": chrono::Utc::now().timestamp_millis(),
    }));
}

let result = self.tool_calling_service
    .execute_tool(tool_name, input_params)
    .await;
```

**Line 581** (replace TODO comment):
```rust
// Emit tool execution complete/error event
if let Some(window) = &self.window {
    match &result {
        Ok(output) => {
            let _ = window.emit("tool-execution-complete", serde_json::json!({
                "tool_name": tool_name,
                "output": output,
                "timestamp": chrono::Utc::now().timestamp_millis(),
            }));
        }
        Err(error) => {
            let _ = window.emit("tool-execution-error", serde_json::json!({
                "tool_name": tool_name,
                "error": error.to_string(),
                "timestamp": chrono::Utc::now().timestamp_millis(),
            }));
        }
    }
}
```

---

## Verification Steps

### 1. Compile Check
```bash
cd src-tauri
cargo check
```

### 2. Run Tests
```bash
cargo test --lib
cargo test --test '*'
```

### 3. Manual E2E Testing

**Tool History**:
1. Start app: `npm run dev`
2. Send message that triggers tool usage (e.g., "Search for Rust news")
3. Open Tool History panel
4. Verify records appear with correct input/output
5. Test filters (by tool name, status, date)
6. Test export (JSON and CSV)
7. Test statistics display
8. Test clear history button

**Tool Settings**:
1. Open Settings > Tools
2. Toggle tool enabled/disabled
3. Adjust timeout values
4. Save and reload app
5. Verify settings persisted

**Real-time Updates**:
1. Send tool-using message
2. Watch for loading indicator during execution
3. Verify success/error status updates immediately
4. Check execution time display

---

## Testing Checklist

- [ ] `cargo check` passes with no errors
- [ ] `cargo test` shows all tests passing
- [ ] Frontend compiles with no TypeScript errors
- [ ] Tool History panel loads without errors
- [ ] Tool History shows real records from database
- [ ] Filters work correctly (tool name, status, date range)
- [ ] Search works across input/output/errors
- [ ] Export to JSON produces valid JSON
- [ ] Export to CSV produces valid CSV
- [ ] Statistics calculate correctly
- [ ] Clear history works with confirmation
- [ ] Tool Settings panel loads without errors
- [ ] Settings can be modified and saved
- [ ] Settings persist after app restart
- [ ] Real-time tool execution shows loading state
- [ ] Real-time tool execution shows success/error
- [ ] Execution time displays correctly

---

## Release Checklist

- [ ] All code changes committed with meaningful messages
- [ ] Version bumped to v3.3.1 in `Cargo.toml` and `package.json`
- [ ] CHANGELOG.md updated with v3.3.1 entry
- [ ] All tests passing (69+ tests)
- [ ] E2E manual testing completed
- [ ] Documentation updated (ROADMAP.md, PROGRESS.md)
- [ ] Build successful for macOS and Windows
- [ ] GitHub release created with binaries
- [ ] Release notes published

---

## Timeline

**Day 1 (4-6 hours)**:
- Morning: Create IPC command files (3-4 hours)
- Afternoon: Register commands and implement event emission (1-2 hours)
- Evening: Run tests and fix any issues

**Day 2 (2-3 hours)**:
- Morning: Manual E2E testing (1-2 hours)
- Afternoon: Update documentation and version numbers (30 min)
- Evening: Build and release (1 hour)

**Total**: 6-9 hours over 1-2 days

---

## Risk Assessment

**Risk Level**: ðŸŸ¢ LOW

**Why Low Risk?**:
1. Services are already fully implemented and tested
2. Frontend components are already fully implemented and tested
3. IPC commands are simple wrappers with minimal logic
4. Changes are additive (no breaking changes to existing code)
5. All new code will have unit tests

**Potential Issues**:
- Incorrect type mapping between Rust and TypeScript (mitigated by testing)
- Window handle not available for event emission (mitigated by Option<Window>)
- Database connection issues (already handled in services)

---

## Success Criteria

âœ… v3.3.1 is successful if:

1. Tool History panel displays real data from database
2. All filters, search, and export functions work
3. Tool Settings panel can read and write settings
4. Real-time tool execution updates appear in UI
5. All 69+ tests pass
6. No new TypeScript or Rust compilation errors
7. App builds successfully for both platforms

---

**Next Steps**: Begin implementation immediately after approval
